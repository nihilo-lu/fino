# 投资追踪系统数据更新逻辑文档

## 概述

本文档描述投资追踪系统中各项数据之间的联动更新关系。当用户执行添加、编辑或删除操作时，系统会自动更新相关联的数据，包括收益分析、持仓、资金明细等。本文档旨在帮助开发者理解系统的数据流向和更新机制。

---

## 一、核心数据表结构

### 1.1 主要数据表

| 表名 | 说明 | 核心字段 |
|------|------|----------|
| `ledgers` | 账本（按 owner_username 多用户隔离） | id, name, cost_method, owner_username |
| `accounts` | 账户（银行/券商等） | id, ledger_id, name, type, currency_id |
| `transactions` | 交易记录（买入/卖出/分红/开仓/平仓等） | id, ledger_id, account_id, date, type, code, quantity, price, amount, amount_cny, fee |
| `positions` | 持仓快照（由 analytics 同步/重建） | id, ledger_id, account_id, code, name, quantity, avg_cost, current_price |
| `currencies` | 币种与汇率 | id, code, name, symbol, exchange_rate |
| `fund_transactions` | 资金明细主表（借贷记账法） | id, ledger_id, date, type, currency_id, notes, transaction_id |
| `fund_transaction_entries` | 资金分录表（多借多贷） | id, fund_transaction_id, account_id, side, amount, amount_cny, subject_type |
| `return_rate` | 收益率数据（净值法） | date, ledger_id, 单位净值, 累计收益率, 总资产 |

### 1.2 数据流向总览

```
交易记录 (transactions)
        │
        ├──► 持仓更新 ──► positions 表
        │         │
        │         └──► position_history (历史快照)
        │
        ├──► 资金明细联动 ──► fund_transactions + fund_transaction_entries (仅开仓/平仓)
        │
        └──► 收益计算 ──► return_rate 表
                 │
                 ├──► position_history (持仓市值)
                 └──► account_balance_history (账户余额)
```

---

## 二、交易记录操作后的更新逻辑

### 2.1 添加交易记录

**触发入口：** `Database.add_transaction()` → `TransactionCRUD.add_transaction()`

**文件位置：** `database.py` 第732-747行

**更新流程：**

1. **插入交易记录** → 将新交易保存到 `transactions` 表
2. **更新持仓库存** → 调用 `analytics.update_position()` 方法
3. **同步持仓到数据库** → `_sync_position_from_inventory()` 方法将库存数据写入 `positions` 表
4. **更新历史快照** → `_update_history_for_date()` 方法更新持仓历史和账户余额历史
5. **清除相关缓存** → 调用 `clear_related_cache()` 清除账本和账户维度的缓存

**库存管理器处理：**
- **FIFO 库存管理** (`fifo_framework.py`)：按先进先出原则处理买入和卖出
- **WAC 库存管理** (`wac_framework.py`)：按加权平均成本原则处理持仓

**关键代码流程：**
```
add_transaction()
    │
    ├──► transaction_crud.add_transaction()
    │         │
    │         └──► analytics.update_position()
    │                   │
    │                   └──► _sync_position_from_inventory()
    │                             │
    │                             └──► INSERT/UPDATE positions
    │
    ├──► _update_history_for_date()
    │         │
    │         ├──► save_position_history_snapshot()
    │         └──► save_account_balance_history()
    │
    └──► clear_related_cache()
```

### 2.2 编辑交易记录

**触发入口：** `Database.update_transaction()` → `TransactionCRUD.update_transaction()`

**文件位置：** `database.py` 第790-807行

**更新流程：**

1. **更新交易记录** → 修改 `transactions` 表中的对应记录
2. **完全重建持仓** → 调用 `analytics.rebuild_all_positions()` 方法
3. **删除并重建持仓历史** → `_delete_position_history_for_transaction()` 删除相关历史后重建
4. **更新历史数据** → 重新计算指定日期的历史快照
5. **清除缓存** → 清除相关账本和账户的缓存

**与添加操作的区别：** 编辑操作会触发持仓的**完全重建**，而不是增量更新。这是因为编辑交易可能影响整个库存计算链，包括历史成本计算。

**关键代码流程：**
```
update_transaction()
    │
    ├──► transaction_crud.update_transaction()
    │         │
    │         ├──► UPDATE transactions
    │         │
    │         └──► analytics.rebuild_all_positions()
    │                   │
    │                   ├──► 清空库存
    │                   ├──► 从所有交易重建库存
    │                   └──► 同步所有持仓到数据库
    │
    ├──► _delete_position_history_for_transaction()
    │
    ├──► _update_history_for_date()
    │
    └──► clear_related_cache()
```

### 2.3 删除交易记录

**触发入口：** `Database.delete_transaction()` → `TransactionCRUD.delete_transaction()`

**文件位置：** `database.py` 第809-829行

**更新流程：**

1. **获取交易信息** → 先查询被删除交易的详细信息
2. **删除关联的资金明细** → 检查并删除 `fund_transactions` 表中关联的资金明细记录
3. **删除交易记录** → 从 `transactions` 表中删除记录
4. **重建持仓** → 调用 `analytics.rebuild_all_positions()` 重新计算所有持仓
5. **删除持仓历史** → `_delete_position_history_for_transaction()` 删除相关历史快照
6. **更新历史数据** → 重新计算受影响日期的历史快照
7. **清除缓存** → 清除相关账本和账户的缓存

**关键代码流程：**
```
delete_transaction()
    │
    ├──► get_transaction_by_id()  # 获取交易信息
    │
    ├──► transaction_crud.delete_transaction()
    │         │
    │         ├──► DELETE FROM fund_transactions WHERE transaction_id = ?
    │         ├──► DELETE FROM transactions WHERE id = ?
    │         └──► analytics.rebuild_all_positions()
    │
    ├──► _delete_position_history_for_transaction()
    │
    ├──► _update_history_for_date()
    │
    └──► clear_related_cache()
```

---

## 三、持仓更新逻辑详解

### 3.1 持仓更新的触发条件

| 操作类型 | 是否触发持仓更新 | 更新方式 |
|----------|------------------|----------|
| 添加交易 | 是 | 增量更新 |
| 编辑交易 | 是 | 完全重建 |
| 删除交易 | 是 | 完全重建 |
| 切换成本方法 | 是 | 完全重建 |

### 3.2 持仓更新的核心方法

**方法调用链：**
```
Database.add_transaction/update_transaction/delete_transaction
        │
        ▼
Analytics.update_position()          # analytics.py 第160-201行
        │
        ├──► FIFOInventory._process_single_transaction()    # fifo_framework.py
        ├──► WACInventory._process_single_transaction()     # wac_framework.py
        │
        ▼
Analytics._sync_position_from_inventory()   # analytics.py 第203-298行
        │
        ▼
INSERT/UPDATE positions 表
```

### 3.3 FIFO 库存管理逻辑

**文件位置：** `utils\fifo_framework.py`

**买入处理流程：**
1. 检查是否有空头寸需要平仓 (`cover_short_position()`)
2. 剩余数量添加到库存 (`inventory[code].append(record)`)
3. 按日期排序确保 FIFO 顺序

**卖出处理流程：**
1. 从库存中按 FIFO 顺序移除 (`remove_stock()`)
2. 计算已实现损益 (`_calculate_realized_pl()`)
3. 库存不足时创建空头寸 (`_create_short_position()`)

### 3.4 WAC 库存管理逻辑

**文件位置：** `utils\wac_framework.py`

**买入处理：**
- 新持仓：`avg_cost = book_value / quantity`
- 现有持仓：加权平均 `new_avg_cost = (old_total_cost + new_cost) / (old_qty + new_qty)`

**卖出处理：**
- 成本 = `quantity * avg_cost`（使用卖出时的平均成本）
- 更新后：`new_quantity = old_quantity - sold_qty`

### 3.5 完全重建持仓逻辑

**触发条件：**
- 更新交易记录
- 删除交易记录
- 切换成本计算方法
- 系统初始化时

**文件位置：** `analytics.py` 第300-467行

**重建流程：**
1. 清空库存 → `self._rebuild_all_inventory()`
2. 从所有交易记录重建库存 → `fifo_inventory.add_stock_from_df(df)` / `wac_inventory.add_stock_from_df(df)`
3. 同步所有持仓到数据库 → 遍历所有账本和账户

---

## 四、资金明细更新逻辑详解

### 4.1 开仓/平仓联动的资金明细

**触发入口：** `Database.add_transaction_with_fund()` → `TransactionCRUD.add_transaction_with_fund()`

**文件位置：** `crud_transactions.py` 第898-1022行

**开仓交易的资金分录：**
- 借：账户（持仓科目，`subject_type='position'`）
- 贷：账户（现金科目，`subject_type='cash'`）

**平仓交易的资金分录：**
- 借：账户（现金科目，`subject_type='cash'`）
- 贷：账户（持仓科目，`subject_type='position'`）

### 4.2 删除交易记录时的资金明细联动

**删除流程：**
1. 查询关联的资金明细 → `SELECT transaction_id FROM fund_transactions WHERE id = ?`
2. 删除资金明细主表和分录表
3. 重建持仓
4. 更新账户余额历史

### 4.3 独立资金明细操作

**添加资金明细** (`Database.add_fund_transaction()`)：
- 独立于交易记录的资金操作
- 支持类型：本金投入、本金撤出、收入、支出、内转
- 借贷平衡验证：借方总额必须等于贷方总额

**删除资金明细** (`Database.delete_fund_transaction()`)：
- 检查是否有关联交易
- 如果关联交易：删除所有同批资金明细 + 删除交易记录
- 重建持仓
- 更新账户余额历史

### 4.4 账户余额计算

**计算公式：**
```
balance = total_invest - total_withdraw + total_income - total_expense
          - transfer_out + transfer_in - total_open + total_close
```

**统计规则：** 仅统计 `subject_type='cash'` 的分录

---

## 五、收益分析更新逻辑详解

### 5.1 成本法收益率（持仓层面）

**计算方式：** 浮动盈亏 = 市值 - 成本

**文件位置：** `analytics.py` 第502-570行

**持仓收益计算公式：**
```python
df['cost_cny'] = df['quantity'] * df['avg_cost'] * df['exchange_rate']
df['market_value_cny'] = df['market_value'] * df['exchange_rate']
df['profit'] = df['market_value'] - df['cost']
df['profit_cny'] = df['market_value_cny'] - df['cost_cny']
df['profit_rate'] = (df['profit'] / df['cost'] * 100)
df['profit_rate_cny'] = (df['profit_cny'] / df['cost_cny'] * 100)
```

**触发条件：**
- 持仓数据变更时自动重新计算
- 用户查看收益分析页面时实时计算

### 5.2 净值法收益率（账本层面）

**核心方法：** `Database.generate_return_rate()` → `return_rate_sqlite.py`

**文件位置：** `return_rate_sqlite.py` 第423-520行

**计算公式：**
- **第一天：** `nav = 1`，`shares = capital_amount / nav`
- **后续：** `nav = (total_assets - capital_amount) / prev_total_shares`
- **当日收益率：** `daily_return = (nav - prev_nav) / prev_nav`
- **累计收益率：** `cumulative_return = (nav - 1) / 1`

**数据来源：**
- 发生金额 → `fund_transactions` (type='本金投入'/'本金撤出')
- 账户余额 → `account_balance_history`
- 持仓市值 → `position_history`
- 总资产 = 账户余额 + 持仓市值 + 汇兑损益

### 5.3 已实现损益计算

**触发方式：** 从库存管理器获取，在持仓同步时计算

**FIFO 已实现损益：**
- 卖出时计算每个批次的损益
- 收入按比例分配到各批次
- 公式：`profit = batch_income - batch_cost`

**WAC 已实现损益：**
- 卖出时计算：`profit = sell_income - (sold_quantity * avg_cost)`

**汇率换算：**
```
报表币种损益 = 收入*当前汇率 - 成本*成本汇率
```

---

## 六、历史快照更新逻辑

### 6.1 持仓历史快照

**触发入口：** `Database.save_position_history_snapshot()`

**文件位置：** `database.py` 第1437-1535行

**触发条件：**
- 添加/编辑/删除交易记录后
- 执行历史数据补全时
- 手动触发更新

**计算方式：**
```python
def get_positions_as_of_date(self, as_of_date, ledger_id):
    # 1. 筛选截止日期前的所有交易
    # 2. 临时构建库存管理器
    # 3. 计算各持仓的数量和成本
```

### 6.2 账户余额历史

**触发入口：** `Database.save_account_balance_history()`

**文件位置：** `database.py` 第1737-1830行

**计算方式：**
```
balance_change = cash_change + market_value_change
balance = prev_balance + balance_change
```

### 6.3 批量历史数据补全

**触发入口：** `Database.auto_backfill_history_and_snapshots()`

**文件位置：** `database.py` 第2100-2240行

**补全流程：**
1. 获取所有交易日期范围
2. 遍历每日执行快照
3. 批量补全价格历史
4. 批量补全汇率历史

---

## 七、数据同步触发点总结

### 7.1 交易操作触发汇总

| 操作 | 触发更新 | 涉及数据表 |
|------|----------|------------|
| 添加交易 | 库存更新 → 持仓同步 → 历史快照更新 | transactions, positions, position_history, account_balance_history |
| 编辑交易 | 持仓完全重建 → 历史快照更新 | transactions, positions, position_history, account_balance_history |
| 删除交易 | 持仓完全重建 → 历史快照更新 → 资金明细联动删除 | transactions, positions, position_history, account_balance_history, fund_transactions |

### 7.2 资金明细操作触发汇总

| 操作 | 触发更新 | 涉及数据表 |
|------|----------|------------|
| 添加资金明细 | 账户余额历史更新 → 收益率数据更新 | fund_transactions, fund_transaction_entries, account_balance_history, return_rate |
| 删除资金明细（关联交易） | 持仓重建 → 账户余额历史更新 | fund_transactions, fund_transaction_entries, positions, return_rate |
| 删除资金明细（独立） | 账户余额历史更新 | fund_transactions, fund_transaction_entries, account_balance_history, return_rate |

### 7.3 其他操作触发汇总

| 操作 | 触发更新 | 涉及数据表 |
|------|----------|------------|
| 更新持仓价格 | 持仓市值更新 → 收益率数据更新 | positions, return_rate |
| 切换成本方法 | 库存重建 → 持仓同步 | positions, inventory |
| 更新汇率 | 成本人民币值重算 → 收益率数据更新 | positions (amount_cny), return_rate |
| 手动补全历史 | 持仓历史快照 → 余额历史快照 → 收益率计算 | position_history, account_balance_history, return_rate |

---

## 八、缓存失效策略

**文件位置：** `utils\cache_utils.py`

**触发条件：** 任何数据变更操作后调用 `clear_related_cache()`

**清除参数：**
- `ledger_id`：按账本维度清除
- `account_id`：按账户维度清除

**影响缓存键示例：**
- `_cached_get_transactions`
- `_cached_get_positions`
- `_cached_get_return_rate`

**TTL 设置：** 180-600 秒

---

## 九、关键文件路径汇总

| 功能 | 文件路径 |
|------|----------|
| 主数据库入口 | `database.py` |
| 交易 CRUD | `crud_transactions.py` |
| 逻辑计算层 | `analytics.py` |
| FIFO 库存管理 | `utils\fifo_framework.py` |
| WAC 库存管理 | `utils\wac_framework.py` |
| 收益率计算 | `return_rate_sqlite.py` |
| 交易记录页面 | `views\transactions.py` |
| 持仓管理页面 | `views\positions.py` |
| 资金明细页面 | `views\fund_transactions.py` |
| 收益分析页面 | `views\analysis.py` |
| 缓存工具 | `utils\cache_utils.py` |

---

## 十、常见场景的数据联动示例

### 10.1 场景一：添加买入交易

**操作：** 用户添加一条买入 100 股 A 股的记录

**自动更新：**
1. `transactions` 表新增记录
2. `analytics.update_position()` 更新 A 股库存
3. `positions` 表更新 A 股持仓数量和平均成本
4. `position_history` 新增该日期的持仓快照
5. `account_balance_history` 更新现金减少的记录
6. `return_rate` 重新计算受影响日期的收益率
7. 清除相关缓存

### 10.2 场景二：编辑卖出交易的价格

**操作：** 用户修改一条卖出交易的价格从 10 元改为 12 元

**自动更新：**
1. `transactions` 表更新价格字段
2. `analytics.rebuild_all_positions()` 完全重建持仓
3. `positions` 表重新计算 A 股持仓的平均成本
4. `position_history` 删除并重建相关历史快照
5. `account_balance_history` 更新现金增加的记录
6. `return_rate` 重新计算所有受影响日期的收益率
7. 清除相关缓存

### 10.3 场景三：删除交易记录

**操作：** 用户删除一条买入 50 股 A 股的交易

**自动更新：**
1. 查询关联的资金明细并删除 (`fund_transactions`, `fund_transaction_entries`)
2. `transactions` 表删除记录
3. `analytics.rebuild_all_positions()` 完全重建持仓
4. `positions` 表更新 A 股持仓数量（减少 50 股）
5. `position_history` 删除相关历史快照并重建
6. `account_balance_history` 更新现金增加的记录
7. `return_rate` 重新计算所有受影响日期的收益率
8. 清除相关缓存

### 10.4 场景四：添加独立资金明细

**操作：** 用户添加一条本金投入 10,000 元的记录

**自动更新：**
1. `fund_transactions` 和 `fund_transaction_entries` 新增记录
2. `account_balance_history` 更新现金增加的历史记录
3. `return_rate` 重新计算受影响日期的收益率
4. 清除相关缓存

---

## 十一、总结

本系统的数据更新逻辑遵循以下原则：

1. **交易记录为中心**：交易记录是核心数据源，所有其他数据（持仓、资金明细、收益）都围绕交易记录进行联动更新

2. **增量与全量结合**：
   - 添加操作采用增量更新，效率较高
   - 编辑和删除操作采用全量重建，确保数据一致性

3. **库存驱动持仓**：持仓数据由库存管理器（FIFO 或 WAC）驱动计算，确保成本计算准确

4. **历史快照支撑收益分析**：通过每日持仓快照和账户余额历史，支撑净值法收益率的准确计算

5. **缓存提升性能**：通过缓存机制减少重复计算，同时通过缓存失效策略确保数据一致性

理解以上数据更新逻辑，有助于：
- 排查数据不一致问题
- 优化系统性能
- 开发新功能时正确处理数据联动
